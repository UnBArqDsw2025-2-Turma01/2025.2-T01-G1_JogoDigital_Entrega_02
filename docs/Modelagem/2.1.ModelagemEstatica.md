# 2.1. Módulo Notação UML – Modelagem Estática

Foco_1: Modelagem UML Estática.

Entrega Mínima: 1 Modelo Estático (ESCOPO: Diagrama de Classes; Diagrama de Componentes ou Diagrama de Implantação).

Apresentação (para a professora) explicando o modelo estático especificado, com: (i) rastro claro aos membros participantes (MOSTRAR QUADRO DE PARTICIPAÇÕES & COMMITS); (ii) justificativas & senso crítico sobre o modelo, e (iii) comentários gerais sobre o trabalho em equipe. Tempo da Apresentação: +/- 5min. Recomendação: Apresentar diretamente via Wiki ou GitPages do Projeto. Baixar os conteúdos com antecedência, evitando problemas de internet no momento de exposição nas Dinâmicas de Avaliação.

A Wiki ou GitPages do Projeto deve conter um tópico dedicado ao Módulo Modelagem Estática (Notação UML), com 1 modelo, histórico de versões, referências, e demais detalhamentos gerados pela equipe nesse escopo.


# 2.1. Módulo Modelagem Estática UML

## Introdução

A **Modelagem Estática** na **Unified Modeling Language (UML)** é
fundamental para representar a estrutura de um sistema de software.
Enquanto a modelagem dinâmica foca nos comportamentos e interações ao
longo do tempo, a modelagem estática concentra-se nos **elementos
estruturais**, como classes, pacotes e componentes, além das relações
entre eles.

Essa abordagem fornece uma **visão arquitetural clara**, ajudando tanto
analistas quanto desenvolvedores a compreender a organização interna do
sistema, identificar dependências e planejar a implementação de forma
mais robusta. A UML, mantida pela **Object Management Group (OMG)**,
oferece símbolos padronizados para representar esses aspectos,
favorecendo a comunicação entre todos os envolvidos no projeto.

## Metodologia

A metodologia aplicada pelo grupo se baseou em três representações
principais da modelagem estática em UML:

1. **Diagrama de Classes** – Mostra a estrutura interna do sistema,
detalhando classes, atributos, métodos e relacionamentos.

2. **Diagrama de Implantação** – Evidencia a vizualização dos processadores nos dispositivos de um sistema, links de comunicação e a colocação de um arquivo de software nesse hardware.

3. **Diagrama de Componentes** – Ilustra os blocos de software que podem
ser implementados e implantados, mostrando interfaces e conexões entre
eles.

O processo metodológico envolveu:

- **Revisão conceitual** da notação UML estática.  
- **Escolha de exemplos práticos** aplicados ao projeto da disciplina.  
- **Modelagem dos três diagramas**, com ênfase em papéis, dependências e
organização estrutural.  

## Participantes

<font size="3"><p style="text-align: center">Tabela 1: Participantes</p></font>

<div align="center">
<table>
  <thead>
    <tr>
      <th>Nome</th>
      <th>Função</th>
      <th>Data</th>
      <th>Hora</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/caioduart3">Caio Duarte</a></td>
      <td>Diagrama de Implantação</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="https://github.com/danielle-soaress">Danielle Soares</a></td>
      <td>Diagrama de Implantação</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="https://github.com/EnzoEmir">Enzo Emir</a></td>
      <td>Diagrama de Classes</td>
      <td>17/09/2025</td>
      <td>22:25</td>
    </tr>
    <tr>
      <td><a href="https://github.com/felixlaryssa">Laryssa Félix</a></td>
      <td>Diagrama de Componentes</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></td>
      <td>Diagrama de Classes</td>
      <td>17/09/2025</td>
      <td>22:25</td>
    </tr>
    <tr>
      <td><a href="https://github.com/MM4k">Marcelo Makoto</a></td>
      <td>Diagrama de Classes</td>
      <td>17/09/2025</td>
      <td>22:25</td>
    </tr>
    <tr>
      <td><a href="https://github.com/dudaa28">Maria Eduarda</a></td>
      <td>Diagrama de Implantação</td>
      <td>20/09/2025</td>
      <td>15:30</td>
    </tr>
    <tr>
      <td><a href="https://github.com/RafaelSchadt">Rafael Welz</a></td>
      <td>Diagrama de Componentes</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="https://github.com/VictorPontual">Victor Pontual</a></td>
      <td>Diagrama de Componentes</td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
</div>

<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>

## Desenvolvimento

### Diagrama de Classes  

<font size="3"><p style="text-align: center">Tabela 2: Participantes Classes</p></font>

<div align="center">
<table>
  <thead>
    <tr>
      <th>Nome</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/EnzoEmir">Enzo Emir</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/MM4k">Marcelo Makoto</a></td>
    </tr>
  </tbody>
</table>
</div>

O **Diagrama de Classes** é provavelmente o mais utilizado na UML, pois representa a **espinha dorsal** de um sistema orientado a objetos.  
Ele descreve as **classes** (entidades de software), seus **atributos** (dados que cada objeto guarda) e seus **métodos** (funcionalidades que os objetos podem executar).  

Além disso, o diagrama mostra as **relações entre classes**, que podem assumir diferentes formas:  
- **Associação** → ligação genérica entre classes.  
- **Herança (generalização/especialização)** → quando uma classe “filha” herda características da “classe mãe”.  
- **Agregação** → relação “todo-parte” mais fraca, onde a parte pode existir sem o todo.  
- **Composição** → relação “todo-parte” mais forte, onde a parte só existe junto com o todo.  

Esse diagrama é amplamente usado no **design do software** porque tem correspondência direta com o código em linguagens como Java, Python e C#.   

![Classes](../assets/Estatica/DiagramaDeClasses.png)

<iframe width="560" height="315" src="https://www.youtube.com/embed/Hxe16odUVmw" title="YouTube video player" frameborder="0" allowfullscreen></iframe>


#### Comentários sobre o Trabalho em Equipe

A elaboração desta etapa foi realizada de forma colaborativa em reunião pelo **Microsoft Teams**, onde os três membros designados estiveram presentes e participaram ativamente da discussão/elaboração.  
O processo de modelagem foi feito no **Lucidchart**, ferramenta que possibilitou a criação e edição simultânea do diagrama, garantindo integração e alinhamento entre os integrantes.  

Durante o encontro, cada participante contribuiu com sugestões e validações, assegurando que o resultado final refletisse a visão conjunta do grupo. Essa abordagem colaborativa favoreceu não apenas a qualidade do diagrama produzido, mas também a sinergia do time e a clareza na divisão de responsabilidades.

---

### Diagrama de Implantação  

<font size="3"><p style="text-align: center">Tabela 3: Participantes Implantação</p></font>

<div align="center">
<table>
  <thead>
    <tr>
      <th>Nome</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/caioduart3">Caio Duarte</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/danielle-soaress">Danielle Soares</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/dudaa28">Maria Eduarda</a></td>
    </tr>
  </tbody>
</table>
</div>

<font size="2"><p style="text-align: center">Fonte: Maria Eduarda, 2025.</p></font>

O **Diagrama de Implantação** é um tipo de representação de diagrama UML, que mostra a
a arquitectura de um sistema, incluindo nós e associações *(relacionamentos de comunicação)*, como ambiente de execução de hardware ou software e o middleware *(Software que atua como uma camada de comunicação e integração entre diferentes aplicações e sistemas)* que os conecta <a href="#REF2"><sup>2</sup></a> <a href="#REF3"><sup>3</sup></a>.


Esse diagrama é usado para modelar e demonstrar o ambiente em que o sistema será executado, nos ajudando a compreender e vizualizar como o sistema funciona em um **ambiente real**.


Além disso, o Diagrama de Implantação:  

- Representa **nós físicos** (como servidores, dispositivos móveis, sensores, computadores) e **ambientes de execução** (máquinas virtuais, contêineres, sistemas operacionais).  
- Mostra como os **artefatos de software** (executáveis, bibliotecas, arquivos de configuração, componentes implantados) são distribuídos nesses nós.  
- Pode detalhar **protocolos e conexões de rede** utilizados na comunicação entre os elementos.  
- É útil para documentar tanto a **infraestrutura física** quanto a **infraestrutura lógica**, apoiando decisões de arquitetura e infraestrutura de TI.  
- Ajuda a validar aspectos de **desempenho, escalabilidade e segurança**, ao ilustrar claramente onde cada parte do sistema está implantada.  

Ou seja, esse diagrama conecta a visão lógica do sistema (componentes, classes) à sua **realidade física de execução**, sendo essencial para projetos que precisam considerar **infraestrutura, comunicação e implantação de software** <a href="#REF1"><sup>1</sup></a>.

A seguir esta imagem mostra a execução do diagrama de implantação sobre a aplicação **Jogo Digital Tower Defense minimalista  - Lendas vs Caçadores inspirado em Plant vs Zombiens**:

![Classes](../assets/Estatica/DiagramadeImplantaçao.png)


<font size="2"><p style="text-align: center">Fonte: Caio Duarte, Danielle Soares, Maria Eduarda, 2025.</p></font>


Este diagrama de implantação ilustra a **arquitetura de tempo de execução da aplicação (jogo)**, mostrando a distribuição dos artefatos de software em seus nós de hardware.  


#### Nós de Hardware  

- **Computador de Mesa** (`<<device>> Desktop Computer`):  
  Este é o nó principal onde a aplicação é executada.  


#### Ambientes de Execução  

- **Interpretador Python** (`<<ExecutionEnvironment>> Interpretador Python`):  
  Um ambiente de execução dentro do Computador de Mesa que gerencia a execução dos artefatos baseados em Python.  


#### Artefatos e Relações  

- **LendaVSCacadores.py** (`<<artifact>>`):  
  O artefato principal do jogo. Ele é executado pelo Interpretador Python.  

- **Pygame** (`<<artifact>>`):  
  Uma biblioteca usada pelo jogo *LendaVSCacadores.py*.  
  A dependência é indicada pela seta `<<uses>>`, mostrando que o jogo depende de **Pygame** para funcionar.  

- **SQLite** (`<<artifact>>`):  
  Um banco de dados local que interage diretamente com o jogo *LendaVSCacadores.py*.  
  A conexão é representada por uma linha com um diamante no meio, mostrando a associação entre os dois artefatos.  


A aplicação **LendaVSCacadores** é executada em um **Computador de Mesa** usando o **Interpretador Python**.  
Ela utiliza a biblioteca **Pygame** para suas funcionalidades e interage com um **banco de dados SQLite** para armazenar informações.  


#### Comentários sobre o Trabalho em Equipe

A elaboração desta etapa foi realizada em reunião pelo **Discord**, não gravada, contando com a participação ativa dos três membros designados para o **Diagrama de Implantação**. Dois integrantes estiveram presentes diretamente na execução prática do diagrama, enquanto um membro contribuiu no estudo aprofundado sobre o componente, seus elementos principais e na documentação principal.  

De forma **presencial e online**, todos os três membros — **Caio Duarte, Danielle Soares e Maria Eduarda Andrade** — participaram ativamente do **Foco 1**, garantindo integração e alinhamento entre teoria e prática.  

A ferramenta utilizada para a elaboração do diagrama foi o **Lucidchart**, possibilitando a criação colaborativa e edição simultânea, o que favoreceu a organização do processo e a clareza na modelagem.  

A participação dos integrantes na elaboração do **Foco 1** trouxe visões e opiniões distintas, enriquecendo o trabalho desenvolvido:  

<details>
  <summary><strong><a href="https://github.com/caioduart3">Caio Duarte</a></strong></summary>
  <p>Sobre o diagrama estático de implantação, achei difícil e abstrato de aplicar em implantações de software que não sejam mobile ou web, como é o caso de softwares desktop offline.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/danielle-soaress">Danielle Soares</a></strong></summary>
  <p>Eu particularmente achei o diagrama de implantação muito difícil de encontrar uma notação padrão, tendo uma grande variação de exemplos na internet e materiais didáticos. Além disso, a maioria deles se tratam de sistemas on-line. Por isso, tive dificuldade de entender como funciona esse diagrama.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/dudaa28">Maria Eduarda Andrade</a></strong></summary>
  <p>Achei a atividade bem útil, principalmente pra minha área de interesse em banco de dados, porque deu pra entender melhor como ele se conecta e atua na aplicação. No caso do nosso jogo <em>Torrent Defence: Lendas vs Caçadores</em>, o diagrama ajudou a visualizar como tudo se organiza, porém mesmo sendo uma ferramenta de ajuda, tive uma dificuldade bastante grande para compreende-lo.</p>
</details>
 

---

### Diagrama de Componentes  

<font size="3"><p style="text-align: center">Tabela 4: Participantes Componentes</p></font>

<div align="center">
<table>
  <thead>
    <tr>
      <th>Nome</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/felixlaryssa">Laryssa Félix</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/RafaelSchadt">Rafael Welz</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/VictorPontual">Victor Pontual</a></td>
    </tr>
  </tbody>
</table>
</div>

O **Diagrama de Componentes** fornece uma **visão arquitetural de alto nível**.  
Enquanto classes e pacotes lidam com organização interna, o de componentes mostra **blocos maiores de software** que podem ser desenvolvidos, implantados e até substituídos de forma independente.  

Cada **componente** pode representar:  
- Um módulo compilado.  
- Um serviço externo.  
- Uma parte da aplicação com responsabilidade bem definida.  

Um ponto essencial é a **definição de interfaces**:  
- **Interfaces fornecidas** (o que o componente oferece para os outros).  
- **Interfaces requeridas** (o que o componente precisa dos outros para funcionar).  

Exemplo prático:  
- O componente **Frontend** fornece a interface de usuário, mas requer serviços do **Backend**.  
- O componente **Backend** fornece a lógica de negócios e requer acesso ao **Banco de Dados**.  

Esse diagrama é especialmente útil na fase de **arquitetura de software** e **implantação**, porque ajuda a visualizar como as peças do sistema se comunicam e quais dependências externas existem.  

## Referência Bibliográfica

> <a id="REF1">1.</a> UML-DIAGRAMS. Deployment Diagrams Overview. Disponível em: <https://www.uml-diagrams.org/deployment-diagrams-overview.html>. Acesso em: 20 set. 2025.  

> <a id="REF2">2.</a> CREATELY BLOG. Tutorial do Diagrama de Implantação. Disponível em: <https://creately.com/blog/pt/diagrama/tutorial-do-diagrama-de-implantacao/>. Acesso em: 20 set. 2025.  

> <a id="REF3">3.</a> YOUTUBE. O que é Diagrama de Implantação UML? Disponível em: <https://www.youtube.com/watch?v=DgERD0HgggQ>. Acesso em: 20 set. 2025.  



## Histórico de Versões 📅

| Versão | Data | Descrição | Autor(es) | Revisor(es) |
| :--: | :--: | :--: | :--: | :--: |
| `0.1` | 17/09/2025 | Criação da página, textos explicativos, contribuição para o Diagrama de Classes | [Enzo Emir](https://github.com/EnzoEmir), [Leticia Arisa](https://github.com/Leticia-Arisa-K-Higa), [Marcelo Makoto](https://github.com/MM4k) | [Maria Eduarda Andrade](https://github.com/dudaa28) |
| `0.2` | 20/09/2025 | Diagrama de Implantação | [Caio Duarte](https://github.com/caioduart3), [Danielle Soares](https://github.com/danielle-soaress), [Maria Eduarda Andrade](https://github.com/dudaa28) | - |


<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>